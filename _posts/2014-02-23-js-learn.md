---
layout: post
title: "js异步编程学习纪录"
description: "2014-02-23 js异步编程学习纪录"
category: Technology
tags: [diary,learn]
modified: 2014-03-30
image:
feature: appleback.jpg
comments: true
share: true
---

###从setTimeout开始
一个很有趣的例子：

{% highlight js linenos %}
for (var i = 1; i <= 3; i++) {
setTimeout(function(){ console.log(i); }, 0);
};
{% endhighlight %}

一开始看这段代码时，对于初学者，往往会以为输出的应该是

{% highlight js linenos %}
1
2
3
{% endhighlight %}

包括我自己也这样以为。

但当自己动手测试的时候，发现结果为

{% highlight js linenos %}
4
4
4
{% endhighlight %}

其实这就是js的setTimeout调用机制，先将其调用的函数加入事件队列中，然后在代码执行完后，到事件队列中去依次调用。

###玩转自己的PubSub
PubSub模式即发布订阅模式，在jquery中，bind/on函数就使用的该模式。
意为将元素的事件发布给任何订阅此事件的人。

#####实现方法
对于支持的每种事件类型，唯一需要存储的状态值就
是一个事件处理器清单

PubSub = {handlers: {}}

需要添加事件监听器时，只要将监听器推入数组末尾即可（这意味着
总是会按照添加监听器的次序来调用监听器）。

{% highlight js linenos %}
PubSub.on = function(eventType, handler) {
	if (!(eventType in this.handlers)) {
		this.handlers[eventType] = [];
	}
	this.handlers[eventType].push(handler);
	return this;
}
{% endhighlight %}

接着，等到触发事件的时候，再循环遍历所有的事件处理器。

{% highlight js linenos %}
PubSub.emit = function(eventType) {
	var handlerArgs = Array.prototype.slice.call(arguments, 1);
	for (var i = 0; i < this.handlers[eventType].length; i++) {
		this.handlers[eventType][i].apply(this, handlerArgs);
	}
	return this;
}
{% endhighlight %}